<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ç™ºå…‰é›»çƒ 3D ğŸ’¡</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { font-family: 'Inter', sans-serif; overflow: hidden; margin: 0; }
        #container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body class="bg-gray-900 text-white">

    <div id="container"></div>

    <div class="fixed bottom-8 right-8 z-50">
        <button id="powerSwitch" 
                class="w-20 h-20 bg-white rounded-full shadow-2xl flex items-center justify-center transition-all duration-300 hover:scale-105 active:scale-95">
            <div class="w-16 h-16 bg-gradient-to-b from-gray-200 to-gray-300 rounded-full shadow-inner flex items-center justify-center">
                <div id="switchIndicator" class="w-3 h-3 bg-yellow-400 rounded-full shadow-lg"></div>
            </div>
        </button>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let bulbMesh, innerGlowMesh, filamentMesh;
        let pointLight;
        let composer, bloomPass;
        let isLightOn = true; // é›»çƒã®ON/OFFçŠ¶æ…‹

        const container = document.getElementById('container');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5.0, 3.5, 7.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5.0;
            controls.maxDistance = 22;
            controls.target.set(0, 1.7, 0);

            setupLights();
            createShaderBulb();
            setupPostProcessing();

            // ã‚¹ã‚¤ãƒƒãƒãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            const powerSwitch = document.getElementById('powerSwitch');
            powerSwitch.addEventListener('click', toggleLight);

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0x2a2a3a, 1.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(8, 12, 6);
            scene.add(mainLight);

            const rimLight = new THREE.DirectionalLight(0x4488ff, 0.5);
            rimLight.position.set(-5, 3, -8);
            scene.add(rimLight);

            pointLight = new THREE.PointLight(0xffaa33, 22, 30, 2);
            pointLight.position.set(0, 1.5, 0);
            scene.add(pointLight);
        }

        function createShaderBulb() {
            // ã‚½ã‚±ãƒƒãƒˆ
            const socketGroup = new THREE.Group();
            
            const threadGeometry = new THREE.CylinderGeometry(0.52, 0.48, 0.9, 32);
            const threadMaterial = new THREE.MeshStandardMaterial({
                color: 0x9a9a9a,
                metalness: 0.8,
                roughness: 0.35,
            });
            const threadMesh = new THREE.Mesh(threadGeometry, threadMaterial);
            threadMesh.position.y = -0.45;
            socketGroup.add(threadMesh);

            const capGeometry = new THREE.CylinderGeometry(0.52, 0.5, 0.15, 32);
            const capMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.9,
                roughness: 0.2,
            });
            const capMesh = new THREE.Mesh(capGeometry, capMaterial);
            capMesh.position.y = -0.975;
            socketGroup.add(capMesh);

            scene.add(socketGroup);

            // ã‚¬ãƒ©ã‚¹çƒä½“ï¼ˆå½¢çŠ¶ï¼‰
            const points = [];
            const bulbHeight = 3.2; // é«˜ã•ã‚’ä¸Šã’ã‚‹
            const curve = new THREE.CurvePath();

            // 1. ãƒãƒƒã‚¯éƒ¨åˆ†ï¼ˆã‚½ã‚±ãƒƒãƒˆæ¥ç¶šï¼‰
            curve.add(new THREE.QuadraticBezierCurve(
                new THREE.Vector2(0.48, 0.0),
                new THREE.Vector2(0.47, 0.05),
                new THREE.Vector2(0.46, 0.12)
            ));

            // 2. è‚©éƒ¨åˆ†ï¼ˆæ§ãˆã‚ã«åºƒãŒã‚‹ï¼‰
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(0.46, 0.12),
                new THREE.Vector2(0.5, 0.25),
                new THREE.Vector2(0.65, 0.45),
                new THREE.Vector2(0.88, 0.7)  // Xè»¸ã‚’ã•ã‚‰ã«å°ã•ã
            ));

            // 3. èƒ´ä½“ä¸‹éƒ¨ã‹ã‚‰æœ€å¤§å¹…ã¸
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(0.88, 0.7),
                new THREE.Vector2(1.1, 0.92),
                new THREE.Vector2(1.22, 1.15),
                new THREE.Vector2(1.28, 1.4)  // æœ€å¤§å¹…ã‚’ã•ã‚‰ã«å°ã•ã
            ));

            // 4. èƒ´ä½“ä¸­å¤®ã‹ã‚‰ä¸Šéƒ¨ï¼ˆä¸¸ã¿ã‚’ç¶­æŒï¼‰
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(1.28, 1.4),
                new THREE.Vector2(1.3, 1.75),
                new THREE.Vector2(1.28, 2.1),
                new THREE.Vector2(1.2, 2.4)
            ));

            // 5. ä¸Šéƒ¨ï¼ˆæ»‘ã‚‰ã‹ã«ç´°ããªã‚‹ï¼‰
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(1.2, 2.4),
                new THREE.Vector2(1.08, 2.68),
                new THREE.Vector2(0.9, 2.9),
                new THREE.Vector2(0.68, 3.05)
            ));

            // 6. é ‚ç‚¹æ‰‹å‰ï¼ˆãªã‚ã‚‰ã‹ãªå¼§ï¼‰
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(0.68, 3.05),
                new THREE.Vector2(0.48, 3.13),
                new THREE.Vector2(0.28, 3.18),
                new THREE.Vector2(0.12, 3.195)
            ));

            // 7. é ‚ç‚¹ï¼ˆæ¥µã‚ã¦æ»‘ã‚‰ã‹ã«é–‰ã˜ã‚‹ï¼‰
            curve.add(new THREE.CubicBezierCurve(
                new THREE.Vector2(0.12, 3.195),
                new THREE.Vector2(0.06, 3.1985),
                new THREE.Vector2(0.02, 3.1995),
                new THREE.Vector2(0.0, bulbHeight)
            ));

            const sampledPoints = curve.getPoints(220);
            const glassGeometry = new THREE.LatheGeometry(sampledPoints, 240);

            // ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆã‚¬ãƒ©ã‚¹+å†…éƒ¨ç™ºå…‰ï¼‰
            const glassShaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    lightPosition: { value: new THREE.Vector3(0, 1.5, 0) },
                    lightColor: { value: new THREE.Color(0xffcc77) },
                    glowIntensity: { value: 1.5 },
                    fresnelPower: { value: 3.0 },
                    time: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vViewPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        vPosition = position;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 lightPosition;
                    uniform vec3 lightColor;
                    uniform float glowIntensity;
                    uniform float fresnelPower;
                    uniform float time;
                    
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vViewPosition;
                    
                    void main() {
                        // ãƒ•ãƒ¬ãƒãƒ«åŠ¹æœï¼ˆã‚¨ãƒƒã‚¸ãŒå…‰ã‚‹ï¼‰
                        vec3 viewDir = normalize(vViewPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), fresnelPower);
                        
                        // å…‰æºã‹ã‚‰ã®è·é›¢ã«ã‚ˆã‚‹ç™ºå…‰
                        float distToLight = distance(vPosition, lightPosition);
                        float falloff = 1.0 / (1.0 + distToLight * distToLight * 0.15);
                        
                        // å†…éƒ¨ç™ºå…‰ã®è¨ˆç®—
                        vec3 toLight = normalize(lightPosition - vPosition);
                        float diffuse = max(dot(vNormal, toLight), 0.0);
                        
                        // Yåº§æ¨™ã«ã‚ˆã‚‹ç™ºå…‰ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå…¨ä½“ã«å‡ä¸€ã«åºƒã’ã‚‹ï¼‰
                        float heightGradient = smoothstep(-0.2, 0.5, vPosition.y) * 
                                               smoothstep(3.5, 2.0, vPosition.y);
                        
                        // é ‚ç‚¹ä»˜è¿‘ã®ç™ºå…‰ã‚’å¼·åŒ–
                        float topBoost = smoothstep(2.0, 3.2, vPosition.y) * 1.5;
                        
                        // æ™‚é–“ã«ã‚ˆã‚‹å¾®ç´°ãªæ˜æ»…
                        float flicker = 0.95 + sin(time * 2.0) * 0.05;
                        
                        // ç™ºå…‰è‰²ã®åˆæˆï¼ˆå…¨ä½“çš„ã«æ˜ã‚‹ãï¼‰
                        vec3 glow = lightColor * (falloff + topBoost) * glowIntensity * (heightGradient + 0.8) * flicker;
                        
                        // ã‚¬ãƒ©ã‚¹ã®åŸºæœ¬è‰²ï¼ˆã‚ãšã‹ã«é’ã¿ãŒã‹ã£ãŸé€æ˜ï¼‰
                        vec3 glassColor = vec3(0.95, 0.97, 1.0);
                        
                        // ãƒ•ãƒ¬ãƒãƒ«ã«ã‚ˆã‚‹ã‚¨ãƒƒã‚¸ç™ºå…‰
                        vec3 edgeGlow = lightColor * fresnel * 0.5;
                        
                        // æœ€çµ‚è‰²ã®åˆæˆ
                        vec3 finalColor = glassColor * 0.15 + glow + edgeGlow;
                        
                        // é€æ˜åº¦ã®è¨ˆç®—ï¼ˆä¸­å¿ƒéƒ¨ã¯ã‚ˆã‚Šé€æ˜ã€ã‚¨ãƒƒã‚¸ã¯ä¸é€æ˜ï¼‰
                        float alpha = 0.3 + fresnel * 0.5 + (falloff + topBoost) * 0.3;
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            bulbMesh = new THREE.Mesh(glassGeometry, glassShaderMaterial);
            scene.add(bulbMesh);

            // å¤–å´ã®ã‚¬ãƒ©ã‚¹ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç‰©ç†ãƒ™ãƒ¼ã‚¹ã®é€æ˜ã‚¬ãƒ©ã‚¹ï¼‰
            const outerGlassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                metalness: 0.0,
                roughness: 0.05,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                transmission: 0.95,
                ior: 1.52,
                reflectivity: 0.5,
                side: THREE.FrontSide,
            });

            const outerGlassMesh = new THREE.Mesh(glassGeometry, outerGlassMaterial);
            scene.add(outerGlassMesh);

            // ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆï¼ˆæ§ãˆã‚ã«ï¼‰
            const filamentGroup = new THREE.Group();
            
            const supportGeometry = new THREE.CylinderGeometry(0.02, 0.02, 2.4, 8);
            const supportMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.3,
            });
            const supportMesh = new THREE.Mesh(supportGeometry, supportMaterial);
            supportMesh.position.y = 1.2;
            filamentGroup.add(supportMesh);

            // èºæ—‹ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆ
            const helixPath = new THREE.CurvePath();
            const helixSegments = 90;
            const helixHeight = 1.4;
            const helixRadius = 0.22;
            const helixTurns = 8;

            for (let i = 0; i < helixSegments; i++) {
                const t1 = i / helixSegments;
                const t2 = (i + 1) / helixSegments;
                const angle1 = t1 * Math.PI * 2 * helixTurns;
                const angle2 = t2 * Math.PI * 2 * helixTurns;
                const y1 = t1 * helixHeight + 0.9;
                const y2 = t2 * helixHeight + 0.9;
                
                helixPath.add(new THREE.LineCurve3(
                    new THREE.Vector3(Math.cos(angle1) * helixRadius, y1, Math.sin(angle1) * helixRadius),
                    new THREE.Vector3(Math.cos(angle2) * helixRadius, y2, Math.sin(angle2) * helixRadius)
                ));
            }

            const tubeGeometry = new THREE.TubeGeometry(helixPath, helixSegments, 0.01, 6, false);
            const filamentMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdd88,
                emissive: 0xffaa22,
                emissiveIntensity: 4.0,
                metalness: 0.3,
                roughness: 0.7,
            });
            const filamentWire = new THREE.Mesh(tubeGeometry, filamentMaterial);
            filamentGroup.add(filamentWire);

            scene.add(filamentGroup);
            filamentMesh = filamentGroup;
        }

        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,  // strength
                0.8,  // radius
                0.3   // threshold
            );
            composer.addPass(bloomPass);
        }

        function toggleLight() {
            isLightOn = !isLightOn;
            
            const switchIndicator = document.getElementById('switchIndicator');
            
            if (isLightOn) {
                // ONã®çŠ¶æ…‹ï¼šã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’é»„è‰²ã«
                switchIndicator.className = 'w-3 h-3 bg-yellow-400 rounded-full shadow-lg';
            } else {
                // OFFã®çŠ¶æ…‹ï¼šã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ã‚°ãƒ¬ãƒ¼ã«
                switchIndicator.className = 'w-3 h-3 bg-gray-500 rounded-full shadow-inner';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // ON/OFFçŠ¶æ…‹ã«å¿œã˜ãŸç™ºå…‰åˆ¶å¾¡
            const targetIntensity = isLightOn ? 1.0 : 0.0;
            
            // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®glowIntensityã‚’æ»‘ã‚‰ã‹ã«å¤‰åŒ–
            if (bulbMesh && bulbMesh.material.uniforms) {
                const currentIntensity = bulbMesh.material.uniforms.glowIntensity.value;
                bulbMesh.material.uniforms.glowIntensity.value += (targetIntensity * 1.5 - currentIntensity) * 0.1;
                
                // æ™‚é–“uniformã®æ›´æ–°ï¼ˆONã®æ™‚ã®ã¿æ˜æ»…ï¼‰
                if (isLightOn) {
                    bulbMesh.material.uniforms.time.value = Date.now() * 0.001;
                }
            }

            // ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆã®ç™ºå…‰åˆ¶å¾¡
            if (filamentMesh) {
                const filamentWire = filamentMesh.children[1]; // èºæ—‹éƒ¨åˆ†
                if (filamentWire && filamentWire.material) {
                    const currentEmissive = filamentWire.material.emissiveIntensity;
                    const targetEmissive = isLightOn ? 4.0 : 0.0;
                    filamentWire.material.emissiveIntensity += (targetEmissive - currentEmissive) * 0.1;
                }
                
                // ONã®æ™‚ã®ã¿å›è»¢
                if (isLightOn) {
                    filamentMesh.rotation.y += 0.003;
                }
            }

            // å…‰æºã®åˆ¶å¾¡
            if (pointLight) {
                const targetLightIntensity = isLightOn ? 22 : 0;
                pointLight.intensity += (targetLightIntensity - pointLight.intensity) * 0.1;
                
                // ONã®æ™‚ã®ã¿æ˜æ»…
                if (isLightOn && pointLight.intensity > 1.0) {
                    const flicker = Math.sin(Date.now() * 0.002) * 0.15 + 0.85;
                    pointLight.intensity = 22 * flicker;
                }
            }

            // Bloomã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆ¶å¾¡
            if (bloomPass) {
                const targetBloom = isLightOn ? 1.2 : 0.0;
                bloomPass.strength += (targetBloom - bloomPass.strength) * 0.1;
            }

            composer.render();
        }

        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
